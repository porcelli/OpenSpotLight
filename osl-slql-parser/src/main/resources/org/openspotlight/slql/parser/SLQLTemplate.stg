/*
 * OpenSpotLight - Open Source IT Governance Platform
 *  
 * Copyright (c) 2009, CARAVELATECH CONSULTORIA E TECNOLOGIA EM INFORMATICA LTDA 
 * or third-party contributors as indicated by the @author tags or express 
 * copyright attribution statements applied by the authors.  All third-party 
 * contributions are distributed under license by CARAVELATECH CONSULTORIA E 
 * TECNOLOGIA EM INFORMATICA LTDA. 
 * 
 * This copyrighted material is made available to anyone wishing to use, modify, 
 * copy, or redistribute it subject to the terms and conditions of the GNU 
 * Lesser General Public License, as published by the Free Software Foundation. 
 * 
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Lesser General Public License  for more details. 
 * 
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this distribution; if not, write to: 
 * Free Software Foundation, Inc. 
 * 51 Franklin Street, Fifth Floor 
 * Boston, MA  02110-1301  USA 
 * 
 *********************************************************************** 
 * OpenSpotLight - Plataforma de Governança de TI de Código Aberto 
 *
 * Direitos Autorais Reservados (c) 2009, CARAVELATECH CONSULTORIA E TECNOLOGIA 
 * EM INFORMATICA LTDA ou como contribuidores terceiros indicados pela etiqueta 
 * @author ou por expressa atribuição de direito autoral declarada e atribuída pelo autor.
 * Todas as contribuições de terceiros estão distribuídas sob licença da
 * CARAVELATECH CONSULTORIA E TECNOLOGIA EM INFORMATICA LTDA. 
 * 
 * Este programa é software livre; você pode redistribuí-lo e/ou modificá-lo sob os 
 * termos da Licença Pública Geral Menor do GNU conforme publicada pela Free Software 
 * Foundation. 
 * 
 * Este programa é distribuído na expectativa de que seja útil, porém, SEM NENHUMA 
 * GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU ADEQUAÇÃO A UMA
 * FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor do GNU para mais detalhes.  
 * 
 * Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto com este
 * programa; se não, escreva para: 
 * Free Software Foundation, Inc. 
 * 51 Franklin Street, Fifth Floor 
 * Boston, MA  02110-1301  USA
 */
group SLQL;

compilationUnit(selects, generalCollatorLevel) ::= 
<<
	validate(session, variableValues, inputNodes);
	
	SLQuery query = session.createQuery();
	<generalCollatorLevel>
	query<selects>;
	
	SLQueryResult result = null;
	if (inputNodes != null) {
	    result = query.execute(inputNodes);
	} else {
	    result = query.execute();
	}
	
	return result.getNodes();

	if(!isValid(variables)){
		throw new InvalidParameterException();
	}
>>

generalCollatorLevel(collatorLevel) ::= "query.setCollatorStrength(<collatorLevel>);"

selectCollatorLevel(collatorLevel) ::= ".collator(<collatorLevel>)"

collatorLevelIdentical()	::= "Collator.IDENTICAL"
collatorLevelPrimary() 		::= "Collator.PRIMARY"
collatorLevelSecondary()	::= "Collator.SECONDARY"
collatorLevelTertiary()		::= "Collator.TERTIARY"

select (selectedElements,byLink,where,orderBy,keepResult,executing,limitOffset,collatorLevel)	
	::= ".select()<selectedElements><byLink>.selectEnd()<where><orderBy><keepResult><executing><limitOffset><collatorLevel>"

selectStar()		::= ".allTypes()"
selectDoubleStar()	::= ".allTypes().onWhere()"

nodeTypes(firstType, moreTypes)	::= "<firstType><moreTypes>"

nodeType(typeName)				::= ".type(\"<typeName>\")"
nodeTypeWithSubTypes(typeName)	::= ".type(\"<typeName>\").subTypes()"

startWithCommaNodeType(nodeType)	::= ".comma().<nodeType>"

moreNodeTypes(nodeTypes)	::= "<nodeTypes>"


byLink(byLinkDefinitions)	::= "<byLinkDefinitions>"

byLinkDefinition(linkType, linkDirections)	::= ".comma().byLink(\"<linkType>\")<linkDirections>"

linkDirections(linkDirectionOptions)	::= "<linkDirectionOptions>"

linkDirectionABBoth()	::= ".any()"
linkDirectionAB()		::= ".any()"
linkDirectionABoth()	::= ".any()"
linkDirectionBBoth()	::= ".any()"
linkDirectionA()		::= ".a()"
linkDirectionB()		::= ".b()"
linkDirectionBoth()		::= ".any()"


where(content)	::= ".where()<content>.whereEnd()"

executing(times)	::= ".executeXTimes(<times>)"

whereGroupByNodeType(nodeType,expr)	::= "<nodeType><expr>.typeEnd()"

booleanAndOperator(lhs,rhs)	::= "<lhs>.and().openBracket()<rhs>.closeBracket()"
booleanOrOperator(lhs,rhs)	::= "<lhs>.or().openBracket()<rhs>.closeBracket()"

negatedOperator(expr)	::= ".not()<expr>"

whereProperty(operator, propertyName, value)	::= ".each().property(\"<propertyName>\")<operator>.value(<value>)"
whereLinkCount(operator, linkName, direction, value)	::= ".each().link(\"<linkName>\")<direction>.count()<operator>.value(<value>)"

operator(op)	::= "<op>"

startsWithOperator()		::= ".startsWith()"
endsWithOperator()			::= ".endsWith()"
containsOperator()			::= ".contains()"
equalsOperator()			::= ".equalsTo()"
greaterOperator()			::= ".greaterThan()"
lesserOperator()			::= ".lesserThan()"
greaterOrEqualsOperator()	::= ".greaterOrEqualThan()"
lesserOrEqualsOperator()	::= ".lesserOrEqualThan()"
notEqualsOperator()			::= ".not().equalsTo()"

anyValue(value)	::= "<value>"

nullValue()		::= "null"
trueValue()		::= "true"
falseValue()	::= "false"

stringValue(value)	::= "<value>"
intValue(value)		::= "<value>" 
decValue(value)		::= "<value>"


booleanVariableValue(variableName)	::= "getBooleanValue(\"<variableName>\")"
stringVariableValue(variableName)	::= "getStringValue(\"<variableName>\")"
decVariableValue(variableName)		::= "getDecValue(\"<variableName>\")"
intVariableValue(variableName)		::= "getIntValue(\"<variableName>\")"

keepResult()	::= ".keepResult()"

orderBy(content)							::= ".orderBy()<content>.orderByEnd()"
orderByGroupByNodeType(nodeType,properties)	::=	"<nodeType><properties>"
orderProperty(propertyName,orderType)		::= ".property(\"<propertyName>\")<orderType>"
commaOrderProperty(propertyName,orderType)	::= ".comma().property(\"<propertyName>\")<orderType>"

ascType()	::= ".ascending()"
descType()	::= ".descending()"


limit(expr,offset)	::= ".limit(<expr>)<offset>"
offset(expr)		::= ".offset(<expr>)"


defineTargetWithSelect(select) ::= 
<<
	validate(session, variableValues, inputNodes);
	
	SLQuery query = session.createQuery();
	query<select>;

	return query.execute().getNodes();
>>

defineTarget(nodeType) ::= 
<<
	validate(session, variableValues, inputNodes);
	
	SLQuery query = session.createQuery();
	query.select()<nodeType>.selectEnd();

	return query.execute().getNodes();
>>